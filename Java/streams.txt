create stream using-
	Stream.of
	IntStream.range(1,2)
	Arrays.streamOf?
	Collection.stream();

stream start - map(accepts a mapper), returns a stream
stream middle - filter(optioanlly accepts a predicate), returns a stream
	      - sort(optioanlly accepts a comparator), returns a stream

terminal    -forEach(accepts a consumer)
		consumer interface is functional yet 2 methods how
		1 is main function -accept
		2nd is 'andThen' which is default function, with implementation within the interface so this will not count

		collect -  collector: a supplier, an accumulator, a combiner and a finisher.
		collect(Collectors.toList());

		streamSupplier.get().anyMatch(s -> true);   // ok
		streamSupplier.get().noneMatch(s -> true);  // ok


e.g
        Stream<Integer> stream = collection.stream().sorted();
        stream.map(e -> e).forEach(e -> System.out.println(e));
	--------
	
        Employee employee1 = new Employee("Cshok","Kumar",20, "patna");
        Employee employee2 = new Employee("Bshok","Kumar",40, "patna");
        Employee employee3 = new Employee("Ashok","Kumar",10, "patna");
        Employee employee4 = new Employee("Dshok","Kumar",80, "patna");
        Employee employee5 = new Employee("Eshok","Kumar",50, "patna");

        List<Employee> employeeList = new ArrayList<>();
        employeeList.add(employee1);
        employeeList.add(employee2);
        employeeList.add(employee3);
        employeeList.add(employee4);
        employeeList.add(employee5);
        //////////////////
	
	//Show employee names whose name starts with A
	employeeList.stream().map(employee -> employee.getfName())
                .filter(employee -> employee.startsWith("A"))
                .forEach(System.out::println);
		
	//Show employee age who age is more than 25
	employeeList.stream().map(employee -> employee.getAge())
                .filter(employee -> employee > 25)
                .forEach(System.out::println);
		
        ///////////////////// Create your own function
	
	class MyFunction implements Function<Integer, Integer>{
	    @Override
	    public Integer apply(Integer integer) {
		return integer * integer;
	    }
	}
	
	//use in main()
	Stream<Integer>  myStream = Stream.of(1,2,3,4,5,6,7,8);
        List<Integer> mySqrList = myStream.map(new MyFunction()).toList();
        System.out.println(mySqrList);
	
	/////////////////////////// apply filter using lambda
	
	List<Integer> myEvenSqrList = myStream.map(new MyFunction())
                .filter(even -> even%2 == 0)
                .toList();
		
	/////////////////////// apply filer using predicate implementation
	
	class MyPredicate implements Predicate<Integer>{

	    @Override
	    public boolean test(Integer integer) {
		return integer%2 == 0 ? true: false;
	    }
	}
	//use in main()
	
	List<Integer> myEvenSqrList = myStream
                .map(new MyFunction())
                .filter(new MyPredicate())
                .toList();
        System.out.println(myEvenSqrList);
	
	////////////////
